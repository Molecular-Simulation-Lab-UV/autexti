#=
    Program to automate an extended TI simulation setup for GROMOS

    By Mateo Barria-Urenda
=#

using ArgParse
using Printf
using DelimitedFiles
using ConfParser
using Measurements
using Interpolations

## functions
# simple functions
@doc """
    run_next()

Call the next simulation listed in the queuefile and saves that line to the logfile.

Does not check if the queuefile exists or has any lines.
Format for the queue file should be one line per simulation as follows:

`workdir job`

Where workdir is relative to the simulation directory and job is a gromos script (such as one made with `mk_script`) that exists in that directory.
"""
function run_next()
    next = read(`head -n +1 $simuldir/$queuefile`, String)
    workdir = simuldir * "/" * split(next)[1]
    job = split(next)[2]
    run(Cmd(`$command $job`, dir=workdir))
    out = read(`tail -n +2 $simuldir/$queuefile`, String)
    open("$simuldir/$queuefile", "w") do io
        write(io, out)
    end
    if logqueue
        open("$simuldir/$logfile", "a") do io
            write(io, next)
        end
    end
end


@doc """
    read_args(file)

Read a gromos argument file; tipically with the `.arg` extension and return a Dictionary.

Keys in the dictionary correspond to flags given with @ in the argument file.
"""
function read_args(file::IOStream)
    lines = readlines(file)
    line = join(lines, " ")
    sline = split(line)
    inds = findall(x -> occursin("@", x), sline)
    args = Dict()
    for i in 1:(length(inds) - 1)
        keyi = inds[i]
        starti = keyi + 1
        endi = inds[i + 1] - 1
        args[sline[keyi]] = sline[starti:endi]
    end
    keyi = inds[end]
    starti = keyi + 1
    args[sline[keyi]] = sline[starti:end]

    return args
end

function read_args(path::String)
    args = Dict()
    open(path) do io
        args = read_args(io)
    end
    return args
end

@doc """
    call_mk_script(script_args)

Parse a dictionary generated with `read_args()` and call mk_script.
"""
function call_mk_script(script_args::Dict)
    term_args = ""
    for key in keys(script_args)
        term_args *= key * " " * join(script_args[key], " ") * " "
    end
    if gromospath != String[]
        run(`$gromospath/mk_script $(term_args)`, wait=true)
    else
        run(`mk_script $(term_args)`, wait=true)
    end
end


@doc """
    write_joblist(filename, lines)

Write a jobfile at `filename`. `lines` is a list of jobs.

Header is predefined such that lines must be in the format:
`job_id NSTLIM RLAM subdir run_after`
"""
function write_jobfile(filename::AbstractString, lines)
    open(filename, "w") do io
        write(io, "TITLE\n  Generated by ext_ti.jl\nEND\n")
        write(io, "JOBSCRIPTS\njob_id NSTLIM RLAM subdir run_after")
        for line in lines
            write(io, line)
        end
        write(io, "\nEND")
    end
end


@doc """
    sim2id(sim, l)

Return an id string for the sim'th simulation at the `l` lambda point.

This function defines the format of ids.
By default, ids have enough space for 4-decimals lambda points and 99 scripts per lambda point.
Should only be modified along with `formatl()` and opt_... functions.
"""
function sim2id(sim::Real, l::Real)
    return l * 10^(6) + sim
end


@doc """
    formatl(l)

Convert `l` to a string, keeping 4 decimals.

Should only be modified along with `sim2id()` and opt_... functions.
Will need modification if the `PRECALCLAM` block of the simulation generates lambda points with more decimals.
"""
function formatl(l::Real)
     return @sprintf "%1.4f" l
end


# functions to generate files
@doc """
    add_simulation(l)
    add_simulation(l, prev_id, prev_l)

Create a new simulation at l.

If an id of another simulation is given, along with its corresponding lambda,
the end coordinates of that simulation will be used instead of the ones given in
the mk_script argument file.
"""
function add_simulation(l::Real, prev_id=0::Int, prev_l=0::Real)
    script_args = read_args("$simuldir/$mk_script_args")
    sys = string(script_args["@sys"][1])
    files = script_args["@files"]
    joblist_path = string(script_args["@joblist"][1])

    queue = open("$simuldir/$queuefile", "a")

    if prev_id != 0
        idstr = @sprintf "%i" prev_id
        lstr  = formatl(prev_l)
        coor_ind = findnext(x -> occursin("coor", x), files, 1) + 1
        files[coor_ind] = "$prefix$lstr/$(sys)_$(idstr).cnf"
        script_args["@files"] = files
        prev_id = 0  # so that gromos thinks it's the first simulation and uses @files coord
    end

    joblist_lines = Array{String}(undef, 0)
    sim = 1
    if l == 0 && start_scripts > 0
        scripts = eq_scripts + start_scripts
    elseif l == 1 && end_scripts > 1
        scripts = eq_scripts + end_scripts
    else
        scripts = eq_scripts + min_md_scripts
    end

    for i in 1:scripts
        id = sim2id(sim, l)
        if i <= eq_scripts
            nstlim = eq_steps
        else
            nstlim = md_steps
        end

        idstr = @sprintf "%i" id
        prevstr = @sprintf "%i" prev_id
        lstr = formatl(l)
        joblist_line = "\n$idstr\t$nstlim\t$lstr\t$prefix$lstr\t$prevstr"
        push!(joblist_lines, String(joblist_line))

        write(queue, "$prefix$lstr\t$(sys)_$(idstr).run\n")

        sim += 1
        prev_id = id
    end
    id = sim2id(sim, l)
    idstr = @sprintf "%i" id
    prevstr = @sprintf "%i" prev_id
    extra_line = "\n$idstr\t1\t1\t$prefix$lstr\t$prevstr" # so mk_script calls the next job and thus this program
    push!(joblist_lines, String(extra_line))
    write_jobfile("$simuldir/$joblist_path", joblist_lines)

    call_mk_script(script_args)

    # delete extra files
    rm("$simuldir/$prefix$lstr/$(sys)_$(idstr).run")
    rm("$simuldir/$prefix$lstr/$(sys)_$(idstr).imd")

    close(queue)

    return prev_id
end


@doc """
    initialize()

Create the mininum amount of jobs to be run before the first analysis.

Also creates the state and log files; and normally is only called when those files are not found.
"""
function initialize()
    state = open("$simuldir/$statefile", "w")
    simulations = collect(0:stepsb4ext:1)
    if simulations[end] != 1
        append!(simulations, 1)
    end
    prev_id = 0
    prev_l = 0
    for l in simulations
        prev_id = add_simulation(l, prev_id, prev_l)
        lstr = formatl(l)
        write(state, "$lstr\tnan\t0\n")
        prev_l = l
    end
    close(state)
end


@doc """
    extend_simulation(state, l, id)

Add an additional simulation at lambda point `l`, as a continuation of simulation `id`.
"""
function extend_simulation(state::AbstractArray, l::Float64, id::Real)
    queue = open("$simuldir/$queuefile", "w")
    script_args = read_args("$simuldir/$mk_script_args")
    sys = string(script_args["@sys"][1])

    lstr = formatl(l)

    id = id + 1
    idstr = @sprintf "%i" id
    joblist_line = "\n$idstr\t$(md_steps)\t$lstr\t$prefix$lstr\t0"

    next_id = id + 1
    nextstr = @sprintf "%i" next_id
    extra_line = "\n$nextstr\t1\t1\t$prefix$lstr\t$idstr" # so mk_script calls the next job and thus this program
    joblist_path = string(script_args["@joblist"][1])

    write_jobfile("$simuldir/$joblist_path", [joblist_line, extra_line])

    prev_id = id - 1
    prevstr = @sprintf "%i" prev_id
    coor_ind = findnext(x -> occursin("coor", x), files, 1) + 1
    files[coor_ind] = "$prefix$lstr/$(sys)_$(prevstr).cnf"

    script_args["@files"] = files
    call_mk_script(script_args)

    # delete extra files
    rm("$simuldir/$prefix$lstr/$(sys)_$(nextstr).run")
    rm("$simuldir/$prefix$lstr/$(sys)_$(nextstr).imd")

    write(queue, "$prefix$lstr\t$(sys)_$(idstr).run\n")
    close(queue)
end


# functions to call external programs
@doc """
    ext_ti_ana(en,files, fr_files, l, imd, outdir)

Call the program ext_ti_ana and return the estimated errors.

`en_files` and `fr_files` are lists of energy and free energy trajectory files, relative to the `l`'s folder.
Passes parameters from the `imd` file and stores the lambda points predictions in `outdir`; both are relative to `simuldir`.
"""
function ext_ti_ana(en_files, fr_files, l, imd, outdir)
    lstr = formatl(l)
    en_cut = en_files[1+skip4ana:end]
    fr_cut = fr_files[1+skip4ana:end]
    # out = read(Cmd(`ene_ana @prop dvdl @library $ene_ana_lib @topo $topo @en_files $en_cut @fr_files $fr_cut`,
    #                 dir="$simuldir/$prefix$lstr/"), String)
    # open("$simuldir/$prefix$lstr/ext_ti_ene_ana.out", "w") do io
    #     write(io, out)
    # end
    # err = parse(Float64, split(out)[9])
    if gromospath != String[]
        out = read(Cmd(`$gromospath/ext_ti_ana @library $ene_ana_lib @en_files $en_cut @fr_files $fr_cut @imd $simuldir/$imd @slam $lstr r @bootstrap 1000 @countframes @outdir $outdir @lam_precision 4 @verbose`,
                    dir="$simuldir/$prefix$lstr/"), String)
    else
        out = read(Cmd(`ext_ti_ana @library $ene_ana_lib @en_files $en_cut @fr_files $fr_cut @imd $simuldir/$imd @slam $lstr r @bootstrap 1000 @countframes @outdir $outdir @lam_precision 4 @verbose`,
                    dir="$simuldir/$prefix$lstr/"), String)
    end
    open("$simuldir/$prefix$lstr/ext_ti_ana.out", "w") do io
        write(io, out)
    end

    data = readdlm("$outdir/predicted_l$lstr.dat", comments=true)
    plam = data[:, 1]
    ind = findnext(plam .== l, 1)
    err = data[ind, 3]

    return err
end


"""
    ext_ti_merge(mergefile, state, precision=4)

Call ext_ti_merge and save the output to `mergefile`
"""
function ext_ti_merge(mergefile, state, precision=4)
    prediction_files = Array{String}(undef, 0)

    for ind in 1:length(state[:, 1])
        l = state[ind, 1]
        lstr = formatl(l)
        push!(prediction_files, String("$outdir/predicted_l$lstr.dat"))
    end

    if gromospath != String[]
        out = read(Cmd(`$gromospath/ext_ti_merge @lam_precision $precision @files $prediction_files`,
                        dir="$outdir"), String)
    else
        out = read(Cmd(`ext_ti_merge @lam_precision $precision @files $prediction_files`,
                        dir="$outdir"), String)
    end
    open(mergefile, "w") do io
        write(io, out)
    end
end


# math and analysis
@doc raw"""
    integral(x, y)
    integral([x y])
    integral(path)
    integral(path, error=false)

Integrate $y=f(x)$ using samples of `x` and `y` and the trapezoid rule.
If a path is given instead, it will load the file assuming the fist
column is `x` and the secind is `y`. If `error` is set to `true` the third
column is loaded as the error estimate of `y`.
"""
function integrate(x::Array, y::Array)
    sum = 0.
    for i in range(2, length(x))
        a = x[i - 1]
        b = x[i]

        fa = y[i - 1]
        fb = y[i]

        sum += (b - a) * (fa + fb) / 2
    end
    return sum
end

function integrate(xy::Array)
    x = xy[:, 1]
    y = xy[:, 2]
    return integrate(x, y)
end

function integrate(path::AbstractString, error=false::Bool)
    data = readdlm(path, comments=true)
    x = data[:, 1]
    if error
        y = data[:, 2] .± data[:, 3]
    else
        y = data[:, 2]
    end

    return integrate(x, y)
end


"""
    max_y_dist(Ax, Ay, Bx, By)
    max_y_dist(Apath, Bpath)

Compare a list of points A and a list of points B and return
the index of the A point whose y value is furthest from the corresponding
y value of (a linear interpolation of) B at that x value.
"""
function max_y_dist(Ax::Array, Ay::Array, Bx::Array, By::Array)
    dists = zeros(length(Ax))
    interp = LinearInterpolation(Bx, By)
    for ind in 1:length(Ax)
        dists[ind] = abs(Ay[ind] - interp(Ax[ind]))
    end
    return findmax(dists)[end]
end


function max_y_dist(Apath::String, Bpath::String)
    A = readdlm(Apath, comments=true)
    B = readdlm(Bpath, comments=true)

    return max_y_dist(A[:, 1], A[:, 2], B[:, 1], B[:, 2])
end


"""
    max_xy_dist(Ax, Ay, Bx, By)
    max_xy_dist(Apath, Bpath)

Compare a list of points A and a list of points B and return
the index of the A point with the largest XY distance to (a linear interpolation of) B.
These distances are the "minimum distances" to B.
In other words, each Ay is compared to all interpolations of B at each Ax.
The minimum of that operation is saved for every Ay.
The maximum of those distances is used to decide the index.
"""
function max_xy_dist(Ax::Array{Real}, Ay::Array{Real}, Bx::Array{Real}, By::Array{Real})
    mindists = zeros(length(Ax))
    interp = LinearInterpolation(Bx, By)
    for ind in 1:length(Ax)
        dists = zeros(length(Ax))
        for jnd in 1:length(Ax)
            dy = Ay[ind] - interp(Ax[jnd])
            dx = Ax[ind] - Ax[jnd]
            dists[jnd] = sqrt(ax^2 + dy^2)
        end
        mindists[ind] = findmin(dists)[1]
    end
    return findmax(mindists)[end]
end


function max_xy_dist(Apath::String, Bpath::String)
    A = readdlm(Apath, comments=true)
    B = readdlm(Bpath, comments=true)

    return max_y_dist(A[:, 1], A[:, 2], B[:, 1], B[:, 2])
end


# optimization criteria
@doc raw"""
    opt_pred(mergefile, dvdlfile)
    opt_pred(mergefile, dvdlfile, precision)

'Optimise predictions'. Find next point to simulate by checking errors of predicted points.
Return the next $\lambda$ point to simulate; or -1 otherwise.

When this function is used, `pred_tol` is the maximum error estimate allowed for predicted $\lambda$ points.

Precision (by default 4) is passed to `ext_ti_merge`. Must be consistent with `sim2id()` and `formatl()`
"""
function opt_pred(mergefile, dvdlfile, state, precision=4)

    # if previous simulations meet the current criteria, do nothing
    if isfile(mergefile)
        data = readdlm(mergefile, comments=true)
        errs = data[:, 3]
        if ~isfile(dvdlfile)
            write_dvdl(mergefile, dvdlfile, state)
        end
    else
        errs = [Inf]
    end

    if any(errs .> pred_tol)
        # if the criteria not met, make sure data is current
        ext_ti_merge(mergefile, state, precision)
        write_dvdl(mergefile, dvdlfile, state)
        # recheck errors
        data = readdlm(mergefile, comments=true)
        errs = data[:, 3]
        # if it still doesn't meet the criteria, decide the next point
        if any(errs .> pred_tol)
            maxerr = findmax(errs)
            l = data[maxerr[2],1]
            return l
        end
    end
    return -1
end


@doc raw"""
    opt_ydist(mergefile, dvdlfile)
    opt_ydist(mergefile, dvdlfile, precision)

'Optimise distances'. Find next point to simulate by checking shape of predicted points.
Return the next $\lambda$ point to simulate; or -1 otherwise.

When this function is used, `pred_tol` is the maximum difference allowed between the integral of simulated points and of predicted points.

Precision (by default 4) is passed to `ext_ti_merge`. Must be consistent with `sim2id()` and `formatl()`
"""
function opt_ydist(mergefile, dvdlfile, state, precision=4)

    # if previous simulations meet the current criteria, do nothing
    if isfile(mergefile)
        if ~isfile(dvdlfile)
            write_dvdl(mergefile, dvdlfile, state)
        end
        estimate = integrate(dvdlfile, true)
        prediction = integrate(mergefile, true)
        diff = abs(prediction - estimate)
    else
        diff = Inf
    end

    if diff > pred_tol
        # if the criteria not met, make sure data is current
        ext_ti_merge(mergefile, state, precision)
        write_dvdl(mergefile, dvdlfile, state)
        # recheck errors
        estimate = integrate(dvdlfile, true)
        prediction = integrate(mergefile, true)
        diff = abs(prediction - estimate)
        # if it still doesn't meet the criteria, decide the next point
        if diff > pred_tol
            ind = max_y_dist(mergefile, dvdlfile)
            lams = readdlm(mergefile, comments=true)
            l = lams[ind]
            return l
        end
    end
    return -1
end


@doc raw"""
    opt_xydist(mergefile, dvdlfile)
    opt_xydist(mergefile, dvdlfile, precision)

'Optimise xy distances'. Find next point to simulate by checking shape of predicted points.
Return the next $\lambda$ point to simulate; or -1 otherwise.

When this function is used, `pred_tol` is the maximum difference allowed between the integral of simulated points and of predicted points.

Precision (by default 4) is passed to `ext_ti_merge`. Must be consistent with `sim2id()` and `formatl()`
"""
function opt_xydist(mergefile, dvdlfile, state, precision=4)

    # if previous simulations meet the current criteria, do nothing
    if isfile(mergefile)
        if ~isfile(dvdlfile)
            write_dvdl(mergefile, dvdlfile, state)
        end
        estimate = integrate(dvdlfile, true)
        prediction = integrate(mergefile, true)
        diff = abs(prediction - estimate)
    else
        diff = Inf
    end

    if diff > pred_tol
        # if the criteria not met, make sure data is current
        ext_ti_merge(mergefile, state, precision)
        write_dvdl(mergefile, dvdlfile, state)
        # recheck errors
        estimate = integrate(dvdlfile, true)
        prediction = integrate(mergefile, true)
        diff = abs(prediction - estimate)
        # if it still doesn't meet the criteria, decide the next point
        if diff > pred_tol
            ind = max_xy_dist(mergefile, dvdlfile)
            lams = readdlm(mergefile, comments=true)
            l = lams[ind]
            return l
        end
    end
    return -1
end


@doc raw"""
    opt_area(mergefile, dvdlfile)
    opt_area(mergefile, dvdlfile, precision)

'Optimise area differences'. Find next point to simulate by checking integral of predicted points.
Return the next $\lambda$ point to simulate; or -1 otherwise.

When this function is used, `pred_tol` is the maximum difference allowed between the integral of simulated points and of predicted points.

Precision (by default 4) is passed to `ext_ti_merge`. Must be consistent with `sim2id()` and `formatl()`
"""
function opt_areamid(mergefile, dvdlfile, state, precision=4)

    # if previous simulations meet the current criteria, do nothing
    if isfile(mergefile)
        if ~isfile(dvdlfile)
            write_dvdl(mergefile, dvdlfile, state)
        end
        estimate = integrate(dvdlfile, true)
        prediction = integrate(mergefile, true)
        diff = abs(prediction - estimate)
    else
        diff = Inf
    end

    if diff > pred_tol
        # if the criteria not met, make sure data is current
        ext_ti_merge(mergefile, state, precision)
        write_dvdl(mergefile, dvdlfile, state)
        # recheck errors
        estimate = integrate(dvdlfile, true)
        prediction = integrate(mergefile, true)
        diff = abs(prediction - estimate)
        # if it still doesn't meet the criteria, decide the next point
        if diff > pred_tol
            preds = readdlm(mergefile, comments=true)
            ests = readdlm(dvdlfile, comments=true)
            # look for segment more distinct from prediction
            area_diffs = zeros(length(ests[:, 1]) - 1)
            # for every segment of simulated points
            for i in 1:(length(ests[:, 1])-1)
                area_est = integrate(ests[i:i+1, :])
                first = findnext(preds[:, 1] .== ests[i, 1], 1)
                last = findnext(preds[:, 1] .== ests[i + 1, 1], 1)
                area_pred = integrate(preds[first:last, :])
                area_diffs[i] = abs(area_pred - area_est)
            end
            find = findmax(area_diffs)[end]
            first = findnext(preds[:, 1] .== ests[find, 1], 1)
            last = findnext(preds[:, 1] .== ests[find + 1, 1], 1)
            ind = Int((first + last) ÷ 2)
            l = preds[ind, 1]

            return l
        end
    end
    return -1
end



@doc """
    write_dvdl(mergefile, dvdlfile, state)

Extracts dvdl from the ext_ti_merge output for the simulated points only.
"""
function write_dvdl(mergefile, dvdlfile, state)
    out = Array{Float64}(undef, 0, 3)
    sim = sort(state[:, 1])
    data = readdlm(mergefile, comments=true)
    for l in sim
        ind = findnext(data[:, 1] .== l, 1)
        out = [out; data[ind, :]']
    end
    writedlm(dvdlfile, out)
end


"""
    main(simuldir)

Run the program.

Will decide if the next step is to
  1. Run a previously queued simulation
  2. Run gromos analysis programs such as `ext_ti_ana` and `ext_ti_merge`
   2.1. If simulations have too high an error estimate: extend them.
   2.2. If predictions of the TI curve are too dissimilar to the simulated curve: add more points simulation points.
   2.3. Otherwise stop addning more simulations to the queue.
  3. Initialize a new set of simulations if no records of the system are found.

"""
function main(simuldir::String)
    ### load config file
    conf=ConfParse("$simuldir/ext_ti.conf")
    parse_conf!(conf)
    ## paths
    prefix         = retrieve(conf, "paths", "prefix")
    queuefile      = retrieve(conf, "paths", "queuefile")
    logfile        = retrieve(conf, "paths", "logfile")
    statefile      = retrieve(conf, "paths", "statefile")
    command        = retrieve(conf, "paths", "command")
    gromospath     = retrieve(conf, "paths", "gromospath")
    mk_script_args = retrieve(conf, "paths", "mk_script_args")
    ene_ana_lib    = retrieve(conf, "paths", "ene_ana_lib")
    ## initialization params
    eq_scripts     = retrieve(conf, "initialization", "eq_scripts", Int)
    eq_steps       = retrieve(conf, "initialization", "eq_steps", Int)
    md_steps       = retrieve(conf, "initialization", "md_steps", Int)
    min_md_scripts = retrieve(conf, "initialization", "min_md_scripts", Int)
    max_md_scripts = retrieve(conf, "initialization", "max_md_scripts", Int)
    start_scripts  = retrieve(conf, "initialization", "start_scripts", Int)
    end_scripts    = retrieve(conf, "initialization", "end_scripts", Int)
    stepsb4ext     = retrieve(conf, "initialization", "stepsb4ext", Int)
    ## analysis
    dvdl_tol       = retrieve(conf, "analysis", "dvdl_tol", Float64)
    pred_tol       = retrieve(conf, "analysis", "pred_tol", Float64)
    skip4ana       = retrieve(conf, "analysis", "skip4ana", Int)
    ## options
    logqueue       = retrieve(conf, "options", "logqueue", Bool)
    logmerges      = retrieve(conf, "options", "logmerges", Bool)
    criteria       = retrieve(conf, "options", "criteria")
    # if there's a queue, just run the next file
    if isfile("$simuldir/$queuefile") && (read(`cat $simuldir/$queuefile`, String) != "")
        run_next()
    # if there's a progress file, check it and use it to run analyses
    elseif isfile("$simuldir/$statefile") && (read(`cat $simuldir/$statefile`, String) != "")
        script_args = read_args("$simuldir/$mk_script_args")
        files = script_args["@files"]
        topo = files[findnext(x -> occursin("topo", x), files, 1) + 1]
        imd = files[findnext(x -> occursin("input", x), files, 1) + 1]
        sys = string(script_args["@sys"][1])
        outdir = "$simuldir/ext_ti_ana"
        mkpath(outdir)

        # check if l=0 and l=1 should be checked for extensions of be considered exceptions
        tol_exceptions = Array{Float64}(undef, 0)
        if start_scripts > 0
            append!(tol_exceptions, 0.)
        elseif end_scripts > 0
            append!(tol_exceptions, 1.)
        end

        # check the state of any simulations to know error estimates and simulated time
        state = readdlm("$simuldir/$statefile")
        for ind in 1:length(state[:, 1])
            l = state[ind, 1]
            lstr = formatl(l)
            en_files = readdlm("$simuldir/$prefix$lstr/en_files.dat")
            fr_files = readdlm("$simuldir/$prefix$lstr/fr_files.dat")

            # if the reported error is too hith or more simulations have been run since the last check
            if (isnan(state[ind, 2]) || (state[ind, 3] < length(en_files)))
                err = ext_ti_ana(en_files, fr_files, l, imd, outdir)
                state[ind, 2] = err
                state[ind, 3] = length(en_files)
                # if error is NaN or too high, extend (if below maximum scripts)
                # exclude extremes if they were set up to have a specific number of scripts
                if (l ∉ tol_exceptions) && ((isnan(state[ind, 2]) || (err > dvdl_tol)) && ((state[ind, 3] - eq_scripts) < max_md_scripts))
                    sim = state[ind, 3]
                    extendid  = sim2id(sim, l)
                    extend_simulation(state, l, extendid)
                    # this adds to the queue file
                end
                # update state file
                writedlm("$simuldir/$statefile", state)
            end
        end
        # it the queue file is (still) empty, check if it should run ext_ti_ana
        if ~isfile("$simuldir/$queuefile") || (read(`cat $simuldir/$queuefile`, String) == "")
            mergefile = "$outdir/ext_ti_merge.out"
            dvdlfile  = "$outdir/ext_ti_dvdl.out"
            if criteria == "pred"
                nextl = opt_pred(mergefile, dvdlfile, state)
            elseif criteria == "ydist"
                nextl = opt_ydist(mergefile, dvdlfile, state)
            elseif criteria == "xydist"
                nextl = opt_xydist(mergefile, dvdlfile, state)
            elseif criteria == "areamid"
                nextl = opt_areamid(mergefile, dvdlfile, state)
            else
                throw(ArgumentError("Criteria not valid. Options are: pred, ydist, xydist, areamid"))
            end
            if 0 <= nextl <= 1
                if logmerges
                    len = length(state[:, 1])
                    for f in [mergefile, dvdlfile]
                        cp(f, replace(f, ".out" => "_$len.out"), force=true)
                    end
                end
                # Prepare next simulatio
                if nextl in state[:, 1] && nextl ∉ tol_exceptions
                    simind = findnext(state[:, 1] .== nextl, 1)
                    if ((state[simind, 3] - eq_scripts) < max_md_scripts)
                        id = state[simind, 3]
                        extend_simulation(state, nextl, id)
                        # update statefile
                        state = [state; [nextl NaN 0]]
                        writedlm("$simuldir/$statefile", state)
                    end
                else
                    # use latest coordinates of closest simulation
                    # find closest
                    mindiff = findmin(abs.(state[:, 1] .- nextl))
                    close_l = state[:, 1][mindiff[2]]
                    close_sim = Int(state[mindiff[2], 3])
                    close_id = sim2id(close_sim, close_l)
                    # create files and add to queue
                    add_simulation(nextl, close_id, close_l)
                    # update statefile
                    state = [state; [nextl NaN 0]]
                    writedlm("$simuldir/$statefile", state)
                end
            end
        end
        # if there's pending files run them, otherwise stop here
        if isfile("$simuldir/$queuefile") && (read(`cat $simuldir/$queuefile`, String) != "")
            run_next()
        else
            println("State file meets current convergence criteria; no additional simulations were prepared.")
        end
    # it there's no queue and no state files, initialize
    else
        initialize()
        run_next()
    end
end

if abspath(PROGRAM_FILE) == @__FILE__
    s = ArgParseSettings()

    @add_arg_table! s begin
        "simuldir"
            help = "where the simulation is and where the config file will be looked for. Defaults to cwd. Use absolute path."
            arg_type = String
            default = pwd()
    end

    pargs = parse_args(ARGS, s)
    simuldir = pargs["simuldir"]
    main(simuldir)
end
